---

title: Keypoint Detector

keywords: fastai
sidebar: home_sidebar

summary: "Network architecture for the keypoint detector."
description: "Network architecture for the keypoint detector."
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/modules_kp_detector.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># class KPDetector(nn.Module):</span>
<span class="c1">#     &quot;&quot;&quot;Detects main keypoints. Return keypoint position and jacobian near each keypoint.&quot;&quot;&quot;</span>
<span class="c1">#     def __init__(self, block_expansion, num_kp, num_channels, max_features,</span>
<span class="c1">#                  num_blocks, temperature, estimate_jacobian=False, scale_factor=1,</span>
<span class="c1">#                  single_jacobian_map=False, pad=0):</span>
<span class="c1">#         super(KPDetector, self).__init__()</span>

<span class="c1">#         self.predictor = Hourglass(block_expansion, in_features=num_channels,</span>
<span class="c1">#                                    max_features=max_features, num_blocks=num_blocks)</span>

<span class="c1">#         self.kp = nn.Conv2d(in_channels=self.predictor.out_filters, out_channels=num_kp, kernel_size=(7, 7),</span>
<span class="c1">#                             padding=pad)</span>

<span class="c1">#         if estimate_jacobian:</span>
<span class="c1">#             self.num_jacobian_maps = 1 if single_jacobian_map else num_kp</span>
<span class="c1">#             self.jacobian = nn.Conv2d(in_channels=self.predictor.out_filters,</span>
<span class="c1">#                                       out_channels=4 * self.num_jacobian_maps, kernel_size=(7, 7), padding=pad)</span>
<span class="c1">#             self.jacobian.weight.data.zero_()</span>
<span class="c1">#             self.jacobian.bias.data.copy_(torch.tensor([1, 0, 0, 1] * self.num_jacobian_maps, dtype=torch.float))</span>
<span class="c1">#         else:</span>
<span class="c1">#             self.jacobian = None</span>

<span class="c1">#         self.temperature = temperature</span>
<span class="c1">#         self.scale_factor = scale_factor</span>
<span class="c1">#         if self.scale_factor != 1:</span>
<span class="c1">#             self.down = AntiAliasInterpolation2d(num_channels, self.scale_factor)</span>

<span class="c1">#     def forward(self, x):</span>
<span class="c1">#         if self.scale_factor != 1:</span>
<span class="c1">#             x = self.down(x)</span>

<span class="c1">#         feature_map = self.predictor(x)</span>
<span class="c1">#         prediction = self.kp(feature_map)</span>

<span class="c1">#         final_shape = prediction.shape</span>
<span class="c1">#         heatmap = prediction.view(final_shape[0], final_shape[1], -1)</span>
<span class="c1">#         heatmap = F.softmax(heatmap / self.temperature, dim=2)</span>
<span class="c1">#         heatmap = heatmap.view(*final_shape)</span>

<span class="c1">#         out = self.gaussian2kp(heatmap)</span>

<span class="c1">#         if self.jacobian is not None:</span>
<span class="c1">#             jacobian_map = self.jacobian(feature_map)</span>
<span class="c1">#             jacobian_map = jacobian_map.reshape(final_shape[0], self.num_jacobian_maps, 4, final_shape[2],</span>
<span class="c1">#                                                 final_shape[3])</span>
<span class="c1">#             heatmap = heatmap.unsqueeze(2)</span>

<span class="c1">#             jacobian = heatmap * jacobian_map</span>
<span class="c1">#             jacobian = jacobian.view(final_shape[0], final_shape[1], 4, -1)</span>
<span class="c1">#             jacobian = jacobian.sum(dim=-1)</span>
<span class="c1">#             jacobian = jacobian.view(jacobian.shape[0], jacobian.shape[1], 2, 2)</span>
<span class="c1">#             out[&#39;jacobian&#39;] = jacobian</span>

<span class="c1">#         return out</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

